<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Ring V5 - Particle Rings</title>
  <style>
    body {
      margin: 0;
      background: #0a0f18; /* 深色太空背景 */
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    
    /* 大气层地平线样式 */
    #atmospheric-horizon{
      position: absolute;
      width: 360%; /* 调整宽度，使弧度更适合倾斜效果 */
      height: 290vh; /* 调整高度，配合倾斜角度 */
      border-radius: 50%; /* 保持圆形 */
      
      /* 核心定位：降低左边缘，调高右边缘 */
      bottom: -240vh; /* 调整垂直位置 */
      left: -125%; /* 调整水平位置 */
      transform: rotate(-12deg); /* 增大旋转角度，实现左低右高效果 */
      
      /* 本体变成纯黑色，融入背景 */
      background-color: #0A0A14;
      
      /* 阴影效果：沿地平线位置发光，降低辉光强度，避免影响粒子 */
      box-shadow: 
        
        /* 第一层：清晰的地平线亮边（收窄！） */
        0 0 60px 20px rgba(160, 150, 220, 0.32),


        /* 第二层：中度发散的柔光 */
        0 0 160px 70px rgba(110, 100, 150, 0.15),


        /* 第三层：大范围淡淡背景融入光 */
        0 0 260px 120px rgba(50, 50, 80, 0.08);


      
      z-index: -1; /* 放在canvas下层 */
      opacity: 0.45; /* 调整透明度，使效果更自然 */
    }
    
    /* 控制按钮样式 */
    .controls {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 40px;
      z-index: 100;
    }

    .control-btn {
      padding: 10px 32px;
      border-radius: 30px;
      border: none;
      background: rgba(35, 36, 52, 0.7);
      backdrop-filter: blur(14px);
      color: rgba(255, 255, 255, 0.5);
      cursor: pointer;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro", sans-serif;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.5px;
      transition: 
          opacity 0.8s ease-out,
          visibility 0.8s ease-out,
          box-shadow 0.28s ease;
      box-shadow: 
          0 0 30px rgba(140, 110, 255, 0.3),
          0 0 60px rgba(140, 110, 255, 0.15),
          inset 0 0 16px rgba(255, 255, 255, 0.04);
      /* 调整按钮样式确保文本垂直居中且在一行显示 */
      width: 140px;
      text-align: center;
      line-height: 1.6;
      white-space: nowrap; /* 确保文字在一行显示 */
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 60px;
    }

    .control-btn:hover {
      box-shadow:
          0 0 40px rgba(170, 130, 255, 0.45),
          0 0 80px rgba(170, 130, 255, 0.25),
          inset 0 0 18px rgba(255, 255, 255, 0.09);
      transform: translateY(-2px);
    }

    .control-btn:active {
      background: rgba(35, 36, 52, 0.85);
      box-shadow:
          0 0 45px rgba(190, 150, 255, 0.6),
          0 0 90px rgba(190, 150, 255, 0.3),
          inset 0 0 20px rgba(255, 255, 255, 0.15);
    }
  </style>
</head>
<body>
<!-- 大气层地平线 -->
<div id="atmospheric-horizon"></div>

<canvas id="canvas"></canvas>

<!-- 底部控制按钮 -->
<div class="controls">
  <button class="control-btn" id="pauseBtn">Pause<br>暂停</button>
  <button class="control-btn" id="resetBtn">Reset<br>重新开始</button>
</div>

<script>
// =========================
//  Canvas 基础设置
// =========================
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// =========================
//  工具函数
// =========================
const TWO_PI = Math.PI * 2;

function clamp(x, a, b) {
  return Math.max(a, Math.min(b, x));
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

// 柔和的缓动
function easeInOutCubic(t) {
  t = clamp(t, 0, 1);
  return t < 0.5
    ? 4 * t * t * t
    : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// 在 [s, e] 区间内归一化到 0~1
function phase01(u, s, e) {
  return clamp((u - s) / (e - s), 0, 1);
}

// Lamé 曲线 / superellipse
// n=2 为圆；n<2 更柔，n>2 更方
function superellipsePoint(theta, a, b, n) {
  const nn = Math.max(n, 0.1);

  const cosT = Math.cos(theta);
  const sinT = Math.sin(theta);

  const signX = cosT >= 0 ? 1 : -1;
  const signY = sinT >= 0 ? 1 : -1;

  const absCos = Math.abs(cosT);
  const absSin = Math.abs(sinT);

  const x = a * signX * Math.pow(absCos, 2 / nn);
  const y = b * signY * Math.pow(absSin, 2 / nn);

  return { x, y };
}

// 简单的噪声函数（用于粒子抖动）
function noise2D(x, y) {
  return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 % 1;
}

// =========================
//  粒子类
// =========================
// =========================
//    V5 粒子类（忠实复刻 V4 的能量）
// =========================
class Particle {
  constructor(x, y, color) {
    this.reset(x, y, color);
  }

  reset(x, y, color) {
    // 初始化位置属性
    this.x = x || 0;
    this.y = y || 0;
    this.size = this.baseSize || 1.0; // 确保size属性存在

    // ---- 色彩：使用传入的颜色参数 ----
    if (color) {
      // 如果传入了十六进制颜色，转换为RGB数组
      if (color.startsWith('#')) {
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        this.color = [r, g, b];
        this.colorStr = `rgba(${r}, ${g}, ${b}, 1)`;
      } 
      // 如果传入了rgba字符串，解析为RGB数组
      else if (color.startsWith('rgba')) {
        const rgba = color.match(/\d+/g).map(Number);
        this.color = [rgba[0], rgba[1], rgba[2]];
        this.colorStr = color; // 直接使用原始的rgba字符串
      }
      // 假设是RGB数组
      else if (Array.isArray(color) && color.length >= 3) {
        this.color = color;
        this.colorStr = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 1)`;
      }
    } else {
      // 默认使用柔和色调
      const palette = [
        [180, 200, 255],  // silver blue
        [210, 160, 255],  // purple soft
        [120, 170, 255],  // ice blue
        [200, 140, 220]   // deep violet tint
      ];
      this.color = palette[Math.floor(Math.random() * palette.length)];
      this.colorStr = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, 1)`;
    }

    // 转成 rgba()
    this.colorStr = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, 1)`;

    // ---- 初始角度 ----
    this.angle = Math.random() * Math.PI * 2;

    // ---- 固定径向偏移：V4 的稳定核心 ----
    this.radiusOffset = (Math.random() - 0.5) * 14;

    // ---- 尺寸 ----
    this.baseSize = 0.8 + Math.random() * 1.6;  // 调小粒子大小

    // ---- 基础透明度（暗 10%）----
    this.baseAlpha = 0.27 + Math.random() * 0.45;

    // ---- 呼吸参数（极关键）----
    this.breathSpeed = 1.0 + Math.random() * 1.5;  // 降低呼吸速度，减慢径向运动
    this.breathPhase = Math.random() * Math.PI * 2;

    // ---- 绕环旋转速度：保持极慢（V4 特征）----
    this.rotationSpeed =
      (0.005 + Math.random() * 0.01) * 0.50;  // 约 0.0025 ~ 0.0075
  }

  // 接收 time（秒）+ 目标曲线点（superellipse）+ 圆环中心坐标
  update(t, curvePoints, index, total, morphPhase, centerX, centerY) {
    // -------- 1. 粒子的“路径角度”前进 --------
    this.angle += this.rotationSpeed;
    this.angle %= Math.PI * 2;

    // 找到在 curvePoints 上对应位置
    const curveIndex = Math.floor((this.angle / (Math.PI * 2)) * curvePoints.length);
    const target = curvePoints[curveIndex];

    // -------- 2. 呼吸半径（增强呼吸效果）--------
    const breath = Math.sin(t * 0.001 * this.breathSpeed + this.breathPhase) * 6; // 增加呼吸振幅
    const finalRadiusOffset = this.radiusOffset + breath;

    // -------- 3. 计算径向方向 --------
    // 计算相对于圆环中心的坐标，用于确定法向方向
    const relX = target.x - centerX;
    const relY = target.y - centerY;

    // 单位法向方向（粒子往外 · 往内）
    const len = Math.sqrt(relX * relX + relY * relY);
    if (len === 0) {
      // 避免除以零
      this.x = target.x;
      this.y = target.y;
      return;
    }
    const nx = relX / len;
    const ny = relY / len;

    // 最终位置 = 曲线点 + 呼吸偏移
    this.x = target.x + nx * finalRadiusOffset;
    this.y = target.y + ny * finalRadiusOffset;

    // -------- 4. Alpha 呼吸（柔和，增强呼吸感）--------
    const breathAlpha = Math.sin(t * 0.001 * this.breathSpeed + this.breathPhase);
    this.alpha = this.baseAlpha + breathAlpha * 0.15; // 增加alpha变化幅度

    // 钳制范围，确保不闪
    this.alpha = Math.max(0.09, Math.min(0.9, this.alpha));
  }

  draw(ctx, globalAlpha) {
    const a = this.alpha * globalAlpha;

    ctx.save();

    // ---- 柔光层（增强发光效果）----
    ctx.globalAlpha = a * 0.36; // 增强柔光层透明度
    ctx.fillStyle = this.colorStr;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.baseSize * 1.8, 0, Math.PI * 2); // 增加柔光层半径
    ctx.fill();

    // ---- 主粒子 ----
    ctx.globalAlpha = a;
    ctx.fillStyle = this.colorStr;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.baseSize, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

// =========================
  //  基本参数设置
  // =========================
  const R = 120;               // 基础尺度（恢复原始半径）
const NUM_POINTS = 260;      // 采样点
const targetNs = [
  0.8,   // Soft
  1.5,   // Core
  4.0    // Hard
];

const dirAngles = [
  Math.PI / 3,   // +60°
  0,             // 0°
  -Math.PI / 3   // -60°
];

const maxOffset = 120;       // 完全分裂时中心偏移距离

const colors = [
  "#66ccff",  // C1
  "#cc99ff",  // C2
  "#ffcc66"   // C3
];

// 一个完整剧情周期：16 秒
const CYCLE = 16.0;

// 粒子数量配置
const PARTICLES_PER_RING = 180;
const PARTICLES_META_RING = 300;

// 状态管理
const state = {
  paused: false,
  accumulatedTime: 0,
  lastTime: null
};

// 粒子数组
let ringParticles = [];
let metaRingParticles = [];

// 初始化粒子
function initParticles() {
  // 重置状态（用于重新开始功能）
  state.paused = false;
  state.accumulatedTime = 0;
  state.lastTime = null;
  
  // 初始化三个环的粒子
  ringParticles = [];
  for (let ringIndex = 0; ringIndex < 3; ringIndex++) {
    const particles = [];
    for (let i = 0; i < PARTICLES_PER_RING; i++) {
      const angle = (i / PARTICLES_PER_RING) * TWO_PI;
      const p = superellipsePoint(angle, R, R, targetNs[ringIndex]);
      particles.push(new Particle(p.x, p.y, colors[ringIndex]));
    }
    ringParticles.push(particles);
  }

  // 初始化融合后的圆环粒子
  metaRingParticles = [];
  const metaColors = [
    "rgba(180, 200, 255, 0.8)",
    "rgba(210, 160, 255, 0.8)",
    "rgba(120, 170, 255, 0.8)",
    "rgba(200, 140, 220, 0.8)",
    "rgba(255, 200, 100, 0.8)"
  ];

  for (let i = 0; i < PARTICLES_META_RING; i++) {
    const angle = (i / PARTICLES_META_RING) * TWO_PI;
    const p = superellipsePoint(angle, R, R, 2.0);
    const color = metaColors[Math.floor(Math.random() * metaColors.length)];
    metaRingParticles.push(new Particle(p.x, p.y, color));
  }
}

function drawFrame(timestamp) {
  if (!state.lastTime) {
    state.lastTime = timestamp;
  }
  
  const dt = (timestamp - state.lastTime) / 1000;
  state.lastTime = timestamp;
  
  if (!state.paused) {
    state.accumulatedTime += dt;
  }
  
  const elapsed = state.accumulatedTime;
  const t = elapsed * 1000; // 毫秒时间用于噪声
  const u = (elapsed % CYCLE) / CYCLE;  // 0~1

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ===== 分裂 / 聚合时间线 ===== 
  const splitInT  = easeInOutCubic(phase01(u, 0.125, 0.375));
  const splitOutT = easeInOutCubic(phase01(u, 0.60, 0.80));  // 修改聚合时间线为0.6-0.8

  let splitFactor;
  if (u < 0.125) splitFactor = 0.0;
  else if (u < 0.375) splitFactor = splitInT;
  else if (u < 0.60) splitFactor = 1.0;  // 延长完全分裂状态至0.6
  else if (u < 0.80) splitFactor = 1.0 - splitOutT;
  else splitFactor = 0.0;

  const currentOffset = maxOffset * splitFactor;

  // ===== 透明度控制 =====
  // 简化透明度控制，确保圆环始终可见
  let subAlpha = 1.0;
  let mergeAlpha = 1.0;
  
  // 根据时间阶段调整透明度
  if (u < 0.375) {
    // 分裂阶段：子圆环淡入，融合圆形淡出
    const splitProgress = phase01(u, 0.125, 0.375);
    subAlpha = easeInOutCubic(splitProgress);
    mergeAlpha = 1.0 - easeInOutCubic(splitProgress);
  } else if (u < 0.60) {
    // 完全分裂状态：只显示三个子圆环
    subAlpha = 1.0;
    mergeAlpha = 0.0;
  } else if (u < 0.80) {
    // 聚合阶段：子圆环淡出，融合圆形淡入
    const mergeProgress = phase01(u, 0.60, 0.80);
    subAlpha = 1.0 - easeInOutCubic(mergeProgress);
    mergeAlpha = easeInOutCubic(mergeProgress);
  } else {
    // 稳定合一状态：只显示融合圆形
    subAlpha = 0.0;
    mergeAlpha = 1.0;
  }

  // ===== 形状呼吸 =====
  const morphPhase = (elapsed % 4.0) / 4.0;
  let morphT, forward;
  if (morphPhase < 0.5) {
    morphT = morphPhase / 0.5;
    forward = true;
  } else {
    morphT = (morphPhase - 0.5) / 0.5;
    forward = false;
  }
  const easedMorph = easeInOutCubic(morphT);

  // ===== 3. 计算圆环中心的位置 =====
  // 调整运动轨迹，使圆环能在更大范围内移动
  const startX = canvas.width * 0.2;   // 左下方起始位置
  const startY = canvas.height * 0.7;  // 左下方起始位置
  const endX = canvas.width * 0.7;     // 结束位置（向右移动更多）
  const endY = canvas.height * 0.3;    // 结束位置（向上移动）

  // 使用线性插值计算当前位置
  const centerX = lerp(startX, endX, u);
  const centerY = lerp(startY, endY, u);

  // 不再需要translate，因为坐标已经直接包含了centerX和centerY偏移

  // ===== 生成三条子曲线 =====
  const allCurvesPoints = [];

  for (let i = 0; i < 3; i++) {
    const angle = dirAngles[i];
    const tx = Math.cos(angle) * currentOffset;
    const ty = Math.sin(angle) * currentOffset;

    const nStart = 2.0;
    const nEnd = targetNs[i];
    const nCurrent = forward
      ? lerp(nStart, nEnd, easedMorph)
      : lerp(nEnd, nStart, easedMorph);

    const pts = [];
    for (let k = 0; k < NUM_POINTS; k++) {
      const theta = (k / NUM_POINTS) * TWO_PI;
      const p = superellipsePoint(theta, R, R, nCurrent);
      pts.push({ x: p.x + tx + centerX, y: p.y + ty + centerY });
    }
    allCurvesPoints.push(pts);

    if (subAlpha > 0.001) {
      ringParticles[i].forEach(p => {
        p.update(t, pts, 0, 0, morphPhase, centerX, centerY);
        p.draw(ctx, subAlpha);
      });
    }
  }

  // ===== 融合后的圆环 =====
  if (mergeAlpha > 0.001) {
    const circleRef = [];
    for (let k = 0; k < NUM_POINTS; k++) {
      const theta = (k / NUM_POINTS) * TWO_PI;
      const p = superellipsePoint(theta, R, R, 2.0);
      circleRef.push({ x: p.x + centerX, y: p.y + centerY });
    }

    const merged = [];
    for (let k = 0; k < NUM_POINTS; k++) {
      const transitionT = clamp((u - 0.6) / 0.2, 0, 1);  // 更新为新的聚合时间线参数
      const easedTransition = easeInOutCubic(transitionT);

      let bestX, bestY;
      let minDistance = Infinity;

      for (let i = 0; i < 3; i++) {
        const dx = allCurvesPoints[i][k].x - circleRef[k].x;
        const dy = allCurvesPoints[i][k].y - circleRef[k].y;
        const d2 = dx * dx + dy * dy;
        if (d2 < minDistance) {
          minDistance = d2;
          bestX = allCurvesPoints[i][k].x;
          bestY = allCurvesPoints[i][k].y;
        }
      }

      const x = lerp(bestX, circleRef[k].x, easedTransition);
      const y = lerp(bestY, circleRef[k].y, easedTransition);
      merged.push({ x, y });
    }

    // 绘制融合后的圆环粒子
    metaRingParticles.forEach(p => {
      p.update(t, merged, 0, 0, morphPhase, centerX, centerY);
      ctx.save();
      ctx.globalAlpha = p.alpha * mergeAlpha * 0.3;
      ctx.fillStyle = p.colorStr;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.baseSize * 2, 0, TWO_PI);
      ctx.fill();
      ctx.restore();

      p.draw(ctx, mergeAlpha);
    });
  }

  requestAnimationFrame(drawFrame);
}

// 事件监听
window.addEventListener("resize", () => {
  resize();
  initParticles();
});

// 暂停/继续按钮
const pauseBtn = document.getElementById('pauseBtn');
pauseBtn.addEventListener('click', function() {
  // 添加按钮点击反馈效果
  this.style.transform = 'scale(0.95)';
  setTimeout(() => {
    this.style.transform = '';
  }, 100);
  
  state.paused = !state.paused;
  this.innerHTML = state.paused ? 'Continue<br>继续' : 'Pause<br>暂停';
});

// 重新开始按钮
const resetBtn = document.getElementById('resetBtn');
resetBtn.addEventListener('click', function() {
  // 添加按钮点击反馈效果
  this.style.transform = 'scale(0.95)';
  setTimeout(() => {
    this.style.transform = '';
  }, 100);
  
  // 重置时间和状态
  state.accumulatedTime = 0;
  state.paused = false;
  
  // 重新初始化粒子
  initParticles();
  
  // 更新按钮状态
  pauseBtn.innerHTML = 'Pause<br>暂停';
});

// 初始化并开始动画
initParticles();
requestAnimationFrame(drawFrame);

</script>
</body>
</html>