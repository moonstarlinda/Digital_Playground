<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ring V5.1: Visible Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: #00ff00; /* 亮绿色，确保看得见 */
            font-family: monospace;
            z-index: 10;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 10px;
        }
        button {
            pointer-events: auto;
            background: #333;
            color: #fff;
            border: 1px solid #666;
            padding: 5px 10px;
            cursor: pointer;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div id="ui">
    STATUS: <span id="status">INIT</span><br>
    POS X: <span id="posX">0</span><br>
    <button id="restartBtn">RESTART / 重启</button>
</div>

<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusSpan = document.getElementById('status');
    const posXSpan = document.getElementById('posX');
    const restartBtn = document.getElementById('restartBtn');

    let width, height;
    let particles = [];
    
    // 状态枚举
    const STATE = {
        JOURNEY: 0,
        CONFLICT: 1
    };
    
    // 核心配置
    const CONFIG = {
        particleCount: 800,
        radius: 120,          // 圆环半径
        speed: 6,             // 飞行速度 (像素/帧)
        rotationSpeed: 0.02
    };

    let currentState = STATE.JOURNEY;
    let masterX = 0;          // Ring 整体 X
    let masterY = 0;          // Ring 整体 Y
    let time = 0;

    // --- 数学工具：超椭圆 (不变) ---
    function getSuperellipsePos(angle, n, radius) {
        const cosT = Math.cos(angle);
        const sinT = Math.sin(angle);
        const x = radius * Math.sign(cosT) * Math.pow(Math.abs(cosT), 2/n);
        const y = radius * Math.sign(sinT) * Math.pow(Math.abs(sinT), 2/n);
        return { x, y };
    }

    // --- 粒子类 ---
    class Particle {
        constructor(index) {
            this.index = index;
            this.angle = (Math.PI * 2 * index) / CONFIG.particleCount;
            this.rx = 0; // 相对X
            this.ry = 0; // 相对Y
            
            // 分组逻辑
            this.group = index % 3;
            if (this.group === 0) {
                this.color = '#FFD700'; // 黄
                this.targetN = 2.5;     // 胖圆
                this.offX = -60; this.offY = -60;
            } else if (this.group === 1) {
                this.color = '#BF55EC'; // 紫
                this.targetN = 1.5;     // 菱形
                this.offX = 0; this.offY = 0;
            } else {
                this.color = '#00B5FF'; // 蓝
                this.targetN = 0.6;     // 星形
                this.offX = 60; this.offY = 60;
            }
        }

        update() {
            // 1. 决定当前的形状参数 N
            let n = 2.0; // 默认为圆
            let targetOffX = 0;
            let targetOffY = 0;

            if (currentState === STATE.CONFLICT) {
                n = this.targetN;
                targetOffX = this.offX;
                targetOffY = this.offY;
            }

            // 2. 旋转
            let rot = this.angle + time * CONFIG.rotationSpeed * (this.group === 1 ? -1 : 1);

            // 3. 计算相对目标坐标
            let pos = getSuperellipsePos(rot, n, CONFIG.radius);
            
            // 加上偏移目标
            let tx = pos.x + targetOffX;
            let ty = pos.y + targetOffY;

            // 4. 缓动 (Lerp)
            let ease = 0.1;
            this.rx += (tx - this.rx) * ease;
            this.ry += (ty - this.ry) * ease;
        }

        draw(ctx) {
            // 绝对坐标 = 整体位置 + 相对位置
            let x = masterX + this.rx;
            let y = masterY + this.ry;

            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2); // 半径2的实心点
            ctx.fill();
        }
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        restart();
        loop();
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }

    function restart() {
        currentState = STATE.JOURNEY;
        masterX = -200; // 从屏幕左侧外开始
        masterY = height / 2; // 垂直居中
        time = 0;
        
        // 重置粒子
        particles = [];
        for (let i = 0; i < CONFIG.particleCount; i++) {
            particles.push(new Particle(i));
        }
    }

    function loop() {
        requestAnimationFrame(loop);
        
        // 1. 清空背景 (带一点拖尾)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
        ctx.fillRect(0, 0, width, height);

        time++;

        // 2. 逻辑控制
        if (currentState === STATE.JOURNEY) {
            statusSpan.innerText = "JOURNEY (Flying Right)";
            // 简单粗暴：水平向右飞
            masterX += CONFIG.speed;
            masterY = height / 2; // 保持垂直居中

            // 撞击检测
            if (masterX >= width / 2) {
                masterX = width / 2; // 停在中间
                currentState = STATE.CONFLICT;
            }
        } else {
            statusSpan.innerText = "CONFLICT (Exploded)";
            // 停在中间震动
            masterX = width / 2 + (Math.random()-0.5)*2;
            masterY = height / 2 + (Math.random()-0.5)*2;
        }

        // 更新调试信息
        posXSpan.innerText = Math.round(masterX);

        // 3. 绘制粒子
        ctx.globalCompositeOperation = 'lighter'; // 发光模式
        particles.forEach(p => {
            p.update();
            p.draw(ctx);
        });
        ctx.globalCompositeOperation = 'source-over';
    }

    restartBtn.addEventListener('click', restart);

    // 启动
    init();

</script>
</body>
</html>