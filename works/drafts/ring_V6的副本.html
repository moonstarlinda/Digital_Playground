<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ring V6 - Sea & Depths</title>
  <style>
    body {
      margin: 0;
      background: #101525;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    
    canvas {
      display: block;
    }
    
    .info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.6);
      font-size: 12px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div class="info">
    Ring V6 Prototype<br>
    Move mouse to explore depths
  </div>
  <canvas id="canvas"></canvas>

  <script>
    // Canvas Setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Utils
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    // State
    const state = {
      mouseX: width / 2,
      mouseY: height / 2,
      ringX: width / 2,
      ringY: height * 0.3, // Start above water level
      ringRadius: 120,
      time: 0
    };

    // Mouse Input
    window.addEventListener('mousemove', (e) => {
      state.mouseX = e.clientX;
      state.mouseY = e.clientY;
    });

    // Touch Input
    window.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      state.mouseX = touch.clientX;
      state.mouseY = touch.clientY;
    });

    // Water Surface Layer
    class WaterSurface {
      constructor() {
        this.waves = [];
        this.ships = [];
        this.init();
      }

      init() {
        // Create waves
        for (let i = 0; i < 5; i++) {
          this.waves.push({
            y: height * 0.3 + i * 20,
            speed: 0.5 + i * 0.2,
            amplitude: 5 + i * 2,
            frequency: 0.02 + i * 0.01,
            offset: 0
          });
        }

        // Create ship shadows
        for (let i = 0; i < 3; i++) {
          this.ships.push({
            x: -100 - i * 300,
            y: height * 0.25 + Math.random() * 50,
            width: 60 + Math.random() * 40,
            height: 10 + Math.random() * 5,
            speed: 2 + i * 0.5
          });
        }
      }

      update() {
        this.waves.forEach(wave => {
          wave.offset = state.time * wave.speed;
        });

        this.ships.forEach(ship => {
          ship.x += ship.speed;
          if (ship.x > width + 100) {
            ship.x = -100;
          }
        });
      }

      draw() {
        ctx.save();
        
        // Draw waves with layered colors (Xiling Gorge inspiration)
        const waveColors = [
          'rgba(40, 100, 80, 0.7)',   // Darker green - bottom layer
          'rgba(50, 120, 100, 0.6)',  // Medium green - middle layer
          'rgba(60, 140, 110, 0.5)',  // Lighter green - top layer
          'rgba(70, 160, 120, 0.4)',  // Lightest green - surface layer
          'rgba(80, 180, 130, 0.3)'   // Very light green - highlight layer
        ];

        this.waves.forEach((wave, index) => {
          const colorIndex = index % waveColors.length;
          ctx.strokeStyle = waveColors[colorIndex];
          ctx.lineWidth = 1;

          ctx.beginPath();
          for (let x = 0; x < width; x += 2) {
            const y = wave.y + Math.sin(x * wave.frequency + wave.offset) * wave.amplitude;
            if (x === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
        });

        // Draw ship shadows with matching color scheme
        ctx.fillStyle = 'rgba(50, 90, 80, 0.4)';
        this.ships.forEach(ship => {
          ctx.fillRect(ship.x, ship.y, ship.width, ship.height);
        });

        ctx.restore();
      }
    }

    // Seabed Layer
    class Seabed {
      constructor() {
        this.shapes = []; // Only keep shapes, remove particles
        this.init();
      }

      init() {
        // Create abstract shapes (suggesting瓷器) - only keep shapes, remove particles
        this.shapes = [];
        for (let i = 0; i < 5; i++) {
          this.shapes.push({
            x: width * 0.2 + (i * 0.15) * width,
            y: height * 0.6 + Math.random() * height * 0.3,
            width: 40 + Math.random() * 60,
            height: 60 + Math.random() * 80,
            rotation: Math.random() * Math.PI * 2
          });
        }
      }

      draw(enhancement = 0.1, isInsideRing = false) {
        ctx.save();

        // Calculate enhancement factor
        const baseEnhancement = isInsideRing ? enhancement : 0.0; // 0 for outside ring - completely invisible

        // Only draw shapes, remove particles
        let strokeColor, lineWidth;
        if (isInsideRing) {
          // Inside ring: slightly brighter version (for better visibility)
          const enhancedBrightness = Math.min(baseEnhancement * 0.9, 2.0); // Increased enhancement cap
          strokeColor = `rgba(120, 180, 160, 0.3 * ${enhancedBrightness})`; // Brighter color and higher opacity
          lineWidth = 1.3; // Slightly thicker for better visibility
        } else {
          // Outside ring: completely invisible
          ctx.restore();
          return; // Skip drawing outside ring
        }
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = lineWidth;

        this.shapes.forEach(shape => {
          ctx.save();
          ctx.translate(shape.x, shape.y);
          ctx.rotate(shape.rotation);
          
          ctx.beginPath();
          ctx.rect(-shape.width/2, -shape.height/2, shape.width, shape.height);
          ctx.stroke();
          
          ctx.restore();
        });

        ctx.restore();
      }
    }

    // Ring/Eye System
    class RingSystem {
      update() {
        const waterLevel = height * 0.4;
        const isMouseUnderwater = state.mouseY > waterLevel; // Check if mouse is underwater
        
        if (isMouseUnderwater) {
          // Only update ring position if mouse is underwater
          const easing = 0.08;
          state.ringX += (state.mouseX - state.ringX) * easing;
          state.ringY += (state.mouseY - state.ringY) * easing;
        }
      }

      draw() {
        const waterLevel = height * 0.4;
        const isMouseUnderwater = state.mouseY > waterLevel; // Check if mouse is underwater
        
        if (!isMouseUnderwater) {
          return; // Don't draw ring if mouse is not underwater
        }
        
        // Add light border to ring - only visible when mouse is underwater
        ctx.save();
        ctx.strokeStyle = 'rgba(100, 160, 180, 0.3)'; // Light blue border, low opacity
        ctx.lineWidth = 1.5; // Thin border
        ctx.beginPath();
        ctx.arc(state.ringX, state.ringY, state.ringRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }

    // Initialize systems
    const waterSurface = new WaterSurface();
    const seabed = new Seabed();
    const ringSystem = new RingSystem();

    // Main render loop
    function render(timestamp) {
      state.time = timestamp / 1000;

      // Clear canvas
      ctx.fillStyle = '#0a1018';
      ctx.fillRect(0, 0, width, height);

      // Update systems
      waterSurface.update();
      ringSystem.update();

      // Check if ring is below water surface
      const waterLevel = height * 0.4;
      const isRingUnderwater = state.ringY > waterLevel;
      const isMouseUnderwater = state.mouseY > waterLevel; // Check if mouse is underwater

      // Always create dark overlay for underwater (environmental effect, not interactive)
      ctx.save();
      ctx.fillStyle = 'rgba(10, 15, 24, 0.95)';
      ctx.fillRect(0, waterLevel, width, height - waterLevel);
      ctx.restore();

      if (isMouseUnderwater) {
        if (isRingUnderwater) {
          // Enhance seabed in ring area only (clean version)
          ctx.save();
          
          // Create clipping path for ring area with water surface consideration
          ctx.beginPath();
          
          // Create a combined path that respects water surface
          // Only clip the part of ring that is below water surface
          const ringCenterY = state.ringY;
          const ringRadius = state.ringRadius;
          
          if (ringCenterY - ringRadius < waterLevel) {
            // Ring crosses water surface, create a complex path
            ctx.rect(0, waterLevel, width, height - waterLevel);
            ctx.arc(state.ringX, state.ringY, state.ringRadius, 0, Math.PI * 2);
            ctx.clip('evenodd');
          } else {
            // Ring is fully underwater, normal circular clip
            ctx.arc(state.ringX, state.ringY, state.ringRadius, 0, Math.PI * 2);
            ctx.clip();
          }
          
          // No additional overlay/halo effects - keep it clean
          // Directly draw seabed with subtle enhancement
          

          // Draw enhanced seabed (slightly brighter for better visibility)
          seabed.draw(1.8, true); // Increased enhancement for better visibility

          
          ctx.restore();
        }

        // Draw ring system (including border) - only when mouse is underwater
        ringSystem.draw();
      }

      // Draw water surface (always visible, drawn last to avoid being covered)
      waterSurface.draw();


      requestAnimationFrame(render);
    }

    // Start animation
    requestAnimationFrame(render);
  </script>
</body>
</html>